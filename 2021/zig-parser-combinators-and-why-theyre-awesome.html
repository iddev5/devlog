<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Zig, Parser Combinators - and Why They&#39;re Awesome</title>
  <meta name="description" content="In this article we will be exploring what parser combinators are, what runtime parser generation is - why they’re useful, and then walking through a Zig implementation of them.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="/2021/zig-parser-combinators-and-why-theyre-awesome">
  
  
  <link rel="alternate" type="application/rss+xml" title="Hexops&#39; devlog" href="/feed.xml">

  

  
  <meta property="og:title" content="Zig, Parser Combinators - and Why They&#39;re Awesome">
  <meta property="og:site_name" content="Hexops&#39; devlog">
  <meta property="og:url" content="/2021/zig-parser-combinators-and-why-theyre-awesome">
  <meta property="og:description" content="In this article we will be exploring what parser combinators are, what runtime parser generation is - why they’re useful, and then walking through a Zig implementation of them.">
  
  
    <meta property="og:image" content="https://raw.githubusercontent.com/hexops/website/master/media/png/square_logo.png">
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Zig, Parser Combinators - and Why They&#39;re Awesome">
  <meta name="twitter:description" content="In this article we will be exploring what parser combinators are, what runtime parser generation is - why they’re useful, and then walking through a Zig implementation of them.">
  
  
    <meta name="twitter:image:src" content="https://raw.githubusercontent.com/hexops/website/master/media/png/square_logo.png">
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

    <div class="wrapper">

      <a class="site-title" href="/">
        <img alt="Hexops" class="logo color" src="https://raw.githubusercontent.com/hexops/media/main/logo.svg" style="height: 30px;">' devlog
      </a>
      <link href="/assets/font/stylesheet.css?v2" rel="stylesheet">
      <link rel="icon" sizes="any" type="image/svg+xml" href="https://raw.githubusercontent.com/hexops/website/master/media/svg/icon.svg">

      <script async defer data-domain="devlog.hexops.com" src="https://devlog.hexops.com/assets/opendata.js"></script>

      <nav class="site-nav">
        
          
          <a class="page-link" href="/about">About</a>
        
          
          <a class="page-link" href="/archives">Archives</a>
        
          
          <a class="page-link" href="https://github.com/hexops">GitHub</a>
        
      </nav>
  
    </div>
  
  </header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Zig, Parser Combinators - and Why They&#39;re Awesome</h1>
    
    <p class="post-meta"><time datetime="2021-03-10T00:00:00+00:00" itemprop="datePublished">Mar 10, 2021</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Stephen Gutekanst</span></span> •
  
    
    
      
    
      
    
      
        <a href="/categories/zig/">zig,</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
        <a href="/categories/regex/">regex,</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/parsers/">parsers</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  



</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>In this article we will be exploring what <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinators</a> are, what <em>runtime parser generation</em> is - why they’re useful, and then walking through a <a href="https://ziglang.org">Zig</a> implementation of them.</p>

<ul>
  <li><a href="#why-are-parser-combinators-useful">What are parser combinators?</a></li>
  <li><a href="#going-deeper-runtime-parser-generation">Going deeper: <em>runtime parser generation</em></a></li>
  <li><a href="#a-note-about-traditional-regex-engines">A note about traditional regex engines</a></li>
  <li><a href="#implementing-the-parser-interface">Implementing the Parser interface</a>
    <ul>
      <li><a href="#compile-time-vs-run-time">Compile-time vs. run-time</a></li>
      <li><a href="#the-parser-interface">The parser interface</a></li>
      <li><a href="#zig-generics-are-provided-via-type-parameters">Zig generics are provided via type parameters</a></li>
      <li><a href="#zig-runtime-interfaces">Zig runtime interfaces</a></li>
      <li><a href="#type-parameters">Type parameters</a></li>
      <li><a href="#errors-the-parser-interface-can-produce">Errors the Parser interface can produce</a></li>
    </ul>
  </li>
  <li><a href="#our-first-parser">Our first Parser</a>
    <ul>
      <li><a href="#what-actually-is-a-reader">What actually is a “Reader”?</a></li>
      <li><a href="#a-parser-that-parses-a-literal-string">A Parser that parses a literal string</a></li>
      <li><a href="#passing-parameters-to-a-parser-implementation">Passing parameters to a parser implementation</a></li>
      <li><a href="#understanding-zigs-wildconfusing-fieldparentptr">Understanding Zig’s wild/confusing <code class="language-plaintext highlighter-rouge">@fieldParentPtr</code></a></li>
      <li><a href="#implementing-the-rest-of-parse">Implementing the rest of <code class="language-plaintext highlighter-rouge">parse</code></a></li>
    </ul>
  </li>
  <li><a href="#our-first-parser-combinator">Our first <em>parser combinator</em></a></li>
  <li><a href="#using-our-oneof-parser-combinator">Using our OneOf parser combinator</a></li>
  <li><a href="#runtime-parser-generation">Runtime parser generation</a></li>
  <li><a href="#closing-thoughts">Closing thoughts</a></li>
</ul>

<h2 id="what-are-parser-combinators">What are parser combinators?</h2>

<p>A parser parses some text to produce a result:</p>

<p><img src="https://user-images.githubusercontent.com/3173176/110372092-1c234080-800b-11eb-8095-654c3c81354d.png" alt="image" /></p>

<p>A <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinator</a> is a <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher-order function</a> which <em>takes parsers as input</em> and <em>produces a new parser</em> as output:</p>

<p><img src="https://user-images.githubusercontent.com/3173176/110372575-b4b9c080-800b-11eb-9ef8-58f3ee0e1f1d.png" alt="image" /></p>

<h2 id="why-are-parser-combinators-useful">Why are parser combinators useful?</h2>

<p>Let’s say we want to parse the syntax which describes a regular expression: <code class="language-plaintext highlighter-rouge">a[bc].*abc</code></p>

<p>We can define some <em>parsers</em> to help us parse this syntax (e.g. into tokens or AST nodes):</p>

<p><img src="https://user-images.githubusercontent.com/3173176/110375065-b1740400-800e-11eb-987e-b5a7c5a3381b.png" alt="image" /></p>

<p>Suppose that for <code class="language-plaintext highlighter-rouge">a[bc].*abc</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RegexLiteralParser</code> can parse <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code>, but not <code class="language-plaintext highlighter-rouge">abc</code> (the string.)</li>
  <li><code class="language-plaintext highlighter-rouge">RegexRangeOpenParser</code> can parse <code class="language-plaintext highlighter-rouge">[</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">RegexRangeCloseParser</code> can parse <code class="language-plaintext highlighter-rouge">]</code></li>
  <li><code class="language-plaintext highlighter-rouge">RegexAnyParser</code> can parse the <code class="language-plaintext highlighter-rouge">.</code> “any character” syntax.</li>
  <li><code class="language-plaintext highlighter-rouge">RegexRepetitionParser</code> can parse the <code class="language-plaintext highlighter-rouge">*</code> repetition operator.</li>
</ul>

<p>Now that we have these <em>parsers</em>, we can define <em>parser combinators</em> to help us parse the full regular expression. First, we need something to parse a string <code class="language-plaintext highlighter-rouge">abc</code> which we can define as:</p>

<p><img src="https://user-images.githubusercontent.com/3173176/110413375-fa49ae00-804a-11eb-8311-64e737513000.png" alt="image" /></p>

<p>What is <code class="language-plaintext highlighter-rouge">OneOrMore</code>, though? That’s our first parser combinator!</p>

<p>It takes a single parser as input (in this case, <code class="language-plaintext highlighter-rouge">RegexLiteralParser</code>) and uses it to parse the input one or more times. If it succeeded once, the parser combinator succeeded. Otherwise, it failed to parse anything.</p>

<p>Now if we want to parse the <code class="language-plaintext highlighter-rouge">[bc]</code> part of our regex, let’s say it can only contain a literal like <code class="language-plaintext highlighter-rouge">bc</code> (of course, real regex allows far more than this) we can e.g. reuse our new <code class="language-plaintext highlighter-rouge">RegexStringLiteralParser</code>:</p>

<p><img src="https://user-images.githubusercontent.com/3173176/110413643-780db980-804b-11eb-8fe5-8ca97b2e96ca.png" alt="image" /></p>

<p>In this case, <code class="language-plaintext highlighter-rouge">Sequence</code> is a parser combinator which takes multiple parsers and tries to parse them one-after-the-other in order, requiring all to succeed or failing otherwise.</p>

<p>Building upon this basic idea, we can use parser combinators to build a full regex syntax parser:</p>

<p><img src="https://user-images.githubusercontent.com/3173176/110414508-2ebe6980-804d-11eb-9422-0888208fac19.png" alt="image" /></p>

<h2 id="going-deeper-runtime-parser-generation">Going deeper: <em>runtime parser generation</em></h2>

<p>From before, our <em>parser combinator</em> <code class="language-plaintext highlighter-rouge">RegexSyntaxParser</code> is built out of multiple parsers (<code class="language-plaintext highlighter-rouge">Regex...Parser</code>) and ultimately produces an AST describing the syntax for a given regex.</p>

<p>We can use the same combinatorial principle here to introduce a new <em>parser generator</em> called <code class="language-plaintext highlighter-rouge">RegexParser</code> which uses <code class="language-plaintext highlighter-rouge">RegexSyntaxParser</code> to create a <em>brand new parser at runtime</em> that is capable of parsing the actual semantics the regex describes - forming a full regex engine:</p>

<p><img src="https://user-images.githubusercontent.com/3173176/110528627-94eecf00-80d5-11eb-8fb6-f6bb051d9394.png" alt="image" /></p>

<h2 id="a-note-about-traditional-regex-engines">A note about traditional regex engines</h2>

<p><small><em>Revised Mar 10, 2021</em> to clarify a misunderstanding I had about about the difference between DFA and NFA regex engines. Thanks <a href="https://news.ycombinator.com/item?id=26419048">@burntsushi</a> for helping me to learn!</small></p>

<p>Production grade regex engines are either <em>finite automata based</em> or <em>backtracking based</em>, and are described in great detail in <a href="https://swtch.com/~rsc/regexp/regexp1.html">Russ Cox’s article here</a> and <a href="https://swtch.com/~rsc/regexp/regexp2.html">his second article here</a> covering the virtual-machine approach commonly used in regex engines.</p>

<p>It’s worth noting that combinatorial parsing and generating parsers at runtime is very much an <em>uncommon</em> method of implementing a regular expression engine. This is <em>somewhat</em> close to what <a href="https://comby.dev">Comby</a> does in practice, although we use a runtime parser generator instead of parser parser combinators.</p>

<p>One could argue this makes what we’re parsing not strictly <em>regular expressions</em>, although as Larry Wall (author of the Perl programming language) <a href="https://raku.org/archive/doc/design/apo/A05.html">writes</a>, neither are the modern “regexp” pattern matchers you are likely used to:</p>

<blockquote>
  <p>“Regular expressions” […] are only marginally related to real regular expressions. Nevertheless, the term has grown with the capabilities of our pattern matching engines, so I’m not going to try to fight linguistic necessity here. I will, however, generally call them “regexes” (or “regexen”, when I’m in an Anglo-Saxon mood).</p>
</blockquote>

<h2 id="implementing-the-parser-interface">Implementing the Parser interface</h2>

<p>Parser combinators <em>tend</em> to be written in higher-level languages with much fancier type-systems such as Haskell and OCaml, which lend themselves well to higher-order functions like parser combinators.</p>

<p>We’ll be implementing this in <a href="https://ziglang.org">Zig</a>, which is a new low-level language aiming to be a better C.</p>

<h3 id="compile-time-vs-run-time">Compile-time vs. run-time</h3>

<p>Zig has very cool <a href="https://ziglang.org/documentation/master/#comptime">compile-time code execution semantics</a> which help provide its generics. We’ll be exploring these a bit, but since we want to ultimately <em>build parser generators at runtime</em> (in order to execute a regexp) what we’ll be looking at is mostly <em>runtime parser interfaces</em> rather than <em>compile-time parser interfaces</em> (which are very much possible!)</p>

<p>Since we’ll be dealing with heap allocations, our parser will not be able to run at comptime for now. Once <a href="https://github.com/ziglang/zig/issues/1291">Zig gets comptime heap allocations</a> this should be possible and opens up interesting new opportunities.</p>

<h3 id="the-parser-interface">The parser interface</h3>

<p>We need an interface in Zig which describes a <em>parser</em> as we previously mentioned:</p>

<p><img src="https://user-images.githubusercontent.com/3173176/110372092-1c234080-800b-11eb-8095-654c3c81354d.png" alt="image" /></p>

<p>Here it is - there’s a lot to unpack here so we’ll walk through it step-by-step:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">Parser</span><span class="p">(</span><span class="k">comptime</span> <span class="n">Value</span><span class="p">:</span> <span class="k">type</span><span class="p">,</span> <span class="k">comptime</span> <span class="n">Reader</span><span class="p">:</span> <span class="k">type</span><span class="p">)</span> <span class="k">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">Self</span> <span class="o">=</span> <span class="nb">@This</span><span class="p">();</span>
        <span class="mi">_</span><span class="n">parse</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="n">self</span><span class="p">:</span> <span class="o">*</span><span class="n">Self</span><span class="p">,</span> <span class="n">allocator</span><span class="p">:</span> <span class="o">*</span><span class="n">Allocator</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="o">*</span><span class="n">Reader</span><span class="p">)</span> <span class="k">callconv</span><span class="p">(.</span><span class="py">Inline</span><span class="p">)</span> <span class="n">Error</span><span class="o">!?</span><span class="n">Value</span><span class="p">,</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="n">parse</span><span class="p">(</span><span class="n">self</span><span class="p">:</span> <span class="o">*</span><span class="n">Self</span><span class="p">,</span> <span class="n">allocator</span><span class="p">:</span> <span class="o">*</span><span class="n">Allocator</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="o">*</span><span class="n">Reader</span><span class="p">)</span> <span class="k">callconv</span><span class="p">(.</span><span class="py">Inline</span><span class="p">)</span> <span class="n">Error</span><span class="o">!?</span><span class="n">Value</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_parse</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">allocator</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="zig-generics-are-provided-via-type-parameters">Zig generics are provided via type parameters</h3>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">Parser</span><span class="p">(</span><span class="k">comptime</span> <span class="n">Value</span><span class="p">:</span> <span class="k">type</span><span class="p">,</span> <span class="k">comptime</span> <span class="n">Reader</span><span class="p">:</span> <span class="k">type</span><span class="p">)</span> <span class="k">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is a Zig function which takes two arbitrary <code class="language-plaintext highlighter-rouge">type</code> arguments at <code class="language-plaintext highlighter-rouge">comptime</code>, named <code class="language-plaintext highlighter-rouge">Value</code> and <code class="language-plaintext highlighter-rouge">Reader</code>. Uppercase is used to denote the name of a type in Zig. Thes are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Value</code> will be the type of the actual value that the parser will produce (e.g. a string of matched text, or an AST note.)</li>
  <li><code class="language-plaintext highlighter-rouge">Reader</code> will be the type of the actual source of the raw text to parse (we’ll cover this more later.)</li>
</ul>

<p>The function itself <em>returns a new type</em>.</p>

<p>What we’re seeing here is the key way in which <a href="https://ziglang.org/documentation/master/#Generic-Data-Structures">Zig approaches generic data structures</a>: you merely pass around types as parameters - as if they were values - and you write functions which take types as parameters and return types as values. Some examples of valid calls to this function are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Parser(u8, []u8)</code> where <code class="language-plaintext highlighter-rouge">u8</code> is an unsigned 8-bit integer and <code class="language-plaintext highlighter-rouge">[]u8</code> is a slice of unsigned 8-bit integers.</li>
  <li><code class="language-plaintext highlighter-rouge">Parser([]const u8, @TypeOf(reader))</code> where <code class="language-plaintext highlighter-rouge">[]const u8</code> is describing a slice of UTF-8 text (a string) and <code class="language-plaintext highlighter-rouge">reader</code> is some reader type, such as <code class="language-plaintext highlighter-rouge">std.io.fixedBufferStream("foobar")</code>.</li>
</ul>

<h3 id="zig-runtime-interfaces">Zig runtime interfaces</h3>

<p>Now, since we’re trying to define an interface whose actual implementation can be swapped out <em>at runtime</em> - what we need is pretty simple:</p>

<ul>
  <li>A <code class="language-plaintext highlighter-rouge">struct</code> type which has the methods we want every implementation to provide.</li>
  <li>Those methods to <em>call function pointers</em> which are defined as <em>fields</em> of our struct.</li>
</ul>

<p>Basically, if someone wants to implement our interface they just need to create a new instance of <code class="language-plaintext highlighter-rouge">Parser</code> and populate the fields (callbacks) so their implementation is called when the interface is used.</p>

<p>This is the same pattern used by the Zig <a href="https://sourcegraph.com/github.com/ziglang/zig/-/blob/lib/std/mem/Allocator.zig"><code class="language-plaintext highlighter-rouge">std.mem.Allocator</code> interface</a>.</p>

<p>In our case here, the returned struct has a method that consumers of the interface would invoke called <code class="language-plaintext highlighter-rouge">parse</code> - and the function pointer field that implementors will set to get a callback is the <code class="language-plaintext highlighter-rouge">_parse</code> field:</p>

<p><img src="https://user-images.githubusercontent.com/3173176/110578739-ad390b00-8122-11eb-816c-09e1e281db9d.png" alt="image" /></p>

<h3 id="type-parameters">Type parameters</h3>

<p>Let’s look at some of the data types going around here:</p>

<p><img src="https://user-images.githubusercontent.com/3173176/110578578-60553480-8122-11eb-897b-e52e2d45eede.png" alt="image" /></p>

<p>A few other notes:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Error!?Value</code> is just describing the function can return an <code class="language-plaintext highlighter-rouge">Error</code> OR no value OR a <code class="language-plaintext highlighter-rouge">Value</code> type. See Zig’s <a href="https://ziglang.org/documentation/master/#Error-Union-Type">error union types</a> and <a href="https://ziglang.org/documentation/master/#Optionals">optional types</a>.</li>
  <li><code class="language-plaintext highlighter-rouge">callconv(.Inline)</code> is just telling the compiler to inline the function call - since our function isn’t doing a ton.</li>
</ul>

<h3 id="errors-the-parser-interface-can-produce">Errors the Parser interface can produce</h3>

<p>Our error type might start out looking something like this:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">const</span> <span class="n">Error</span> <span class="o">=</span> <span class="k">error</span><span class="p">{</span>
    <span class="n">EndOfStream</span><span class="p">,</span>
<span class="p">}</span> <span class="p">||</span> <span class="n">std</span><span class="p">.</span><span class="py">mem</span><span class="p">.</span><span class="py">Allocator</span><span class="p">.</span><span class="py">Error</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">error{...}</code> describes <a href="https://ziglang.org/documentation/master/#Error-Set-Type">a set of potential errors</a> and <code class="language-plaintext highlighter-rouge">|| std.mem.Allocator.Error</code> merely says to <em>merge</em> the allocator type’s error set with ours - so our potential set of errors includes <em>ours and theirs</em>.</p>

<p>As we start performing different operations within parsers, it will become more complex to describe more potential sources of errors:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">const</span> <span class="n">Error</span> <span class="o">=</span> <span class="k">error</span><span class="p">{</span>
    <span class="n">EndOfStream</span><span class="p">,</span>
    <span class="n">Utf8InvalidStartByte</span><span class="p">,</span>
<span class="p">}</span> <span class="p">||</span> <span class="n">std</span><span class="p">.</span><span class="py">fs</span><span class="p">.</span><span class="py">File</span><span class="p">.</span><span class="py">ReadError</span>
  <span class="p">||</span> <span class="n">std</span><span class="p">.</span><span class="py">fs</span><span class="p">.</span><span class="py">File</span><span class="p">.</span><span class="py">SeekError</span>
  <span class="p">||</span> <span class="n">std</span><span class="p">.</span><span class="py">mem</span><span class="p">.</span><span class="py">Allocator</span><span class="p">.</span><span class="py">Error</span><span class="p">;</span>
</code></pre></div></div>

<p>Zig can often <a href="https://ziglang.org/documentation/master/#Inferred-Error-Sets">infer error sets</a> but only in some contexts today.</p>

<h2 id="our-first-parser">Our first Parser</h2>

<p>All we need to do in order to implement a <code class="language-plaintext highlighter-rouge">Parser</code> is provide the <code class="language-plaintext highlighter-rouge">_parse</code> method, and define its return <code class="language-plaintext highlighter-rouge">Value</code> type and <code class="language-plaintext highlighter-rouge">Reader</code> input type:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">([]</span><span class="kt">u8</span><span class="p">,</span> <span class="nb">@TypeOf</span><span class="p">(</span><span class="n">reader</span><span class="p">))</span> <span class="o">=</span> <span class="o">.</span><span class="p">{</span>
    <span class="p">.</span><span class="py">_parse</span> <span class="o">=</span> <span class="n">myParse</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>In the above, the type <code class="language-plaintext highlighter-rouge">T</code> in <code class="language-plaintext highlighter-rouge">const parser: T</code> is denoting the type of the constant named <code class="language-plaintext highlighter-rouge">parser</code> - in this case it’ll be the type returned by <code class="language-plaintext highlighter-rouge">Parser([]u8, @TypeOf(reader))</code>. And this:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">something</span> <span class="o">=</span> <span class="o">.</span><span class="p">{</span>
    <span class="p">.</span><span class="py">_parse</span> <span class="o">=</span> <span class="n">myParse</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Is the Zig syntax for populating a struct. We’re setting the <code class="language-plaintext highlighter-rouge">_parse</code> field to <code class="language-plaintext highlighter-rouge">myParse</code>. Zig can infer the type of the struct if you write a <code class="language-plaintext highlighter-rouge">.{}</code> instead of <code class="language-plaintext highlighter-rouge">T{}</code> - which avoids the need for us to repeat the call to the <code class="language-plaintext highlighter-rouge">Parser()</code> function which is verbose.</p>

<h3 id="what-actually-is-a-reader">What actually is a “Reader”?</h3>

<p>Up to this point, we’ve just talked about <code class="language-plaintext highlighter-rouge">Reader</code> as being <em>any type</em>.</p>

<p>Similar to our <code class="language-plaintext highlighter-rouge">Parser</code> interface, the Zig standard library <a href="https://sourcegraph.com/github.com/ziglang/zig@f2b96782ecdc9e2f8740eb7d294203b2a585ea52/-/blob/lib/std/io/reader.zig#L13-20">provides a <code class="language-plaintext highlighter-rouge">std.io.Reader</code> interface</a> and there are <a href="https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/ziglang/zig%24+file:%5Elib/std/+fn+reader%28&amp;patternType=literal">many implementors of it</a> including:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">std.fs.File</code></li>
  <li><code class="language-plaintext highlighter-rouge">std.io.fixedBufferStream("foobar")</code></li>
  <li><code class="language-plaintext highlighter-rouge">std.net.Stream</code> (network sockets)</li>
</ul>

<p>However, in contrast to our <code class="language-plaintext highlighter-rouge">Parser</code> type which invokes <em>function pointers</em> at runtime, the <code class="language-plaintext highlighter-rouge">std.io.Reader</code> interface is a <em>compile time type</em> - meaning calls to the underlying implementation do not involve a pointer dereference.</p>

<p>Today, Zig is in early stages (version 0.7) and does not have anything like an interface or trait type (although <a href="https://github.com/ziglang/zig/issues/1268">it seems likely this will be improved in the future</a>.)</p>

<p>This means that, for now, we cannot simply define our function as accepting <em>only</em> an <code class="language-plaintext highlighter-rouge">std.io.Reader</code> interface - instead we must declare that we accept <em>any type</em> which we’ll call <code class="language-plaintext highlighter-rouge">Reader</code>, write our code <em>as if it is an <code class="language-plaintext highlighter-rouge">std.io.Reader</code></em> - and the compiler will just barf if anybody passes something in that <em>isn’t</em> an <code class="language-plaintext highlighter-rouge">std.io.Reader</code>. This can sometimes lead to confusing compiler error messages (“there’s an error in the standard library code? Ah, no, I just needed to pass a <code class="language-plaintext highlighter-rouge">.reader()</code>!”).</p>

<h3 id="a-parser-that-parses-a-literal-string">A Parser that parses a literal string</h3>

<p>If we want a <code class="language-plaintext highlighter-rouge">Parser</code> interface implementation that parses a specific string literal, one way to do that is to also make that a generic function which accepts <em>any</em> reader type (so we’re not restricted to e.g. just file inputs):</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">Literal</span><span class="p">(</span><span class="k">comptime</span> <span class="n">Reader</span><span class="p">:</span> <span class="k">type</span><span class="p">)</span> <span class="k">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="c">// TODO</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is pretty good - but we need some way to have the type we return <em>implement</em> the <code class="language-plaintext highlighter-rouge">Parser</code> interface we defined. The way to do this is by defining a field in our struct:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">Literal</span><span class="p">(</span><span class="k">comptime</span> <span class="n">Reader</span><span class="p">:</span> <span class="k">type</span><span class="p">)</span> <span class="k">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">([]</span><span class="kt">u8</span><span class="p">,</span> <span class="n">Reader</span><span class="p">)</span> <span class="o">=</span> <span class="o">.</span><span class="p">{</span>
            <span class="p">.</span><span class="py">_parse</span> <span class="o">=</span> <span class="n">parse</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now a consumer can write the following to get a literal string parser:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">parser</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">reader</span><span class="p">)).</span><span class="py">parser</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="passing-parameters-to-a-parser-implementation">Passing parameters to a parser implementation</h3>

<p>If we want our <code class="language-plaintext highlighter-rouge">Literal</code> parser to accept a parameter – the literal string to look for – we need to give it a parameter.</p>

<p>In the case of merely passing it a string, we <em>could</em> adjust the signature so that this is possible:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">parser</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="s">"some string"</span><span class="p">,</span> <span class="nb">@TypeOf</span><span class="p">(</span><span class="n">reader</span><span class="p">)).</span><span class="py">parser</span><span class="p">;</span>
</code></pre></div></div>

<p>However, we’ll define ours using an <code class="language-plaintext highlighter-rouge">init</code> method which is more common in Zig data structures:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">Literal</span><span class="p">(</span><span class="k">comptime</span> <span class="n">Reader</span><span class="p">:</span> <span class="k">type</span><span class="p">)</span> <span class="k">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">([]</span><span class="kt">u8</span><span class="p">,</span> <span class="n">Reader</span><span class="p">)</span> <span class="o">=</span> <span class="o">.</span><span class="p">{</span>
            <span class="p">.</span><span class="py">_parse</span> <span class="o">=</span> <span class="n">parse</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">want</span><span class="p">:</span> <span class="p">[]</span><span class="k">const</span> <span class="kt">u8</span><span class="p">,</span>

        <span class="k">const</span> <span class="n">Self</span> <span class="o">=</span> <span class="nb">@This</span><span class="p">();</span>

        <span class="c">// The `want` string must stay alive for as long as the parser will be used.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="n">init</span><span class="p">(</span><span class="n">want</span><span class="p">:</span> <span class="p">[]</span><span class="k">const</span> <span class="kt">u8</span><span class="p">)</span> <span class="n">Self</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">Self</span><span class="p">{</span>
                <span class="p">.</span><span class="py">want</span> <span class="o">=</span> <span class="n">want</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this case, <code class="language-plaintext highlighter-rouge">want</code> is the string literal we want to match - and <code class="language-plaintext highlighter-rouge">[]const u8</code> is Zig’s string type. It describes a slice of immutable (non-modifiable) encoded UTF-8 bytes.</p>

<p>Unlike C, <code class="language-plaintext highlighter-rouge">[]const u8</code> being a slice means it is <em>a pointer to the string in memory and its length</em> - so we don’t have to pass around the length parameter separately or use a null-terminated string. In Zig, there are two ways to represent a string:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">[]const u8</code> (unmodifiable string, most common)</li>
  <li><code class="language-plaintext highlighter-rouge">[]u8</code> (modifiable string)</li>
</ul>

<h3 id="understanding-zigs-wildconfusing-fieldparentptr">Understanding Zig’s wild/confusing <code class="language-plaintext highlighter-rouge">@fieldParentPtr</code></h3>

<p>We’re finally ready to actually have our <code class="language-plaintext highlighter-rouge">Literal</code> parser <em>parse</em> something! We just need to implement our <code class="language-plaintext highlighter-rouge">parse</code> method:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">Literal</span><span class="p">(</span><span class="k">comptime</span> <span class="n">Reader</span><span class="p">:</span> <span class="k">type</span><span class="p">)</span> <span class="k">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">([]</span><span class="kt">u8</span><span class="p">,</span> <span class="n">Reader</span><span class="p">)</span> <span class="o">=</span> <span class="o">.</span><span class="p">{</span>
            <span class="p">.</span><span class="py">_parse</span> <span class="o">=</span> <span class="n">parse</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">want</span><span class="p">:</span> <span class="p">[]</span><span class="k">const</span> <span class="kt">u8</span><span class="p">,</span>
        <span class="o">...</span>
        <span class="k">const</span> <span class="n">Self</span> <span class="o">=</span> <span class="nb">@This</span><span class="p">();</span>

        <span class="k">fn</span> <span class="n">parse</span><span class="p">(</span><span class="n">parser</span><span class="p">:</span> <span class="o">*</span><span class="n">Parser</span><span class="p">([]</span><span class="kt">u8</span><span class="p">,</span> <span class="n">Reader</span><span class="p">),</span> <span class="n">allocator</span><span class="p">:</span> <span class="o">*</span><span class="n">Allocator</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="o">*</span><span class="n">Reader</span><span class="p">)</span> <span class="k">callconv</span><span class="p">(.</span><span class="py">Inline</span><span class="p">)</span> <span class="n">Error</span><span class="o">!?</span><span class="p">[]</span><span class="kt">u8</span> <span class="p">{</span>
            <span class="k">const</span> <span class="n">self</span> <span class="o">=</span> <span class="nb">@fieldParentPtr</span><span class="p">(</span><span class="n">Self</span><span class="p">,</span> <span class="s">"parser"</span><span class="p">,</span> <span class="n">parser</span><span class="p">);</span>
            <span class="o">...</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But wait a minute! In order for the <code class="language-plaintext highlighter-rouge">._parse = parse,</code> assignment to work the first argument to <code class="language-plaintext highlighter-rouge">parse</code> needs to be the <code class="language-plaintext highlighter-rouge">self</code> parameter for a <code class="language-plaintext highlighter-rouge">Parser([]u8, Reader)</code> - so how does <em>our</em> <code class="language-plaintext highlighter-rouge">parse</code> implementation method get to access the <code class="language-plaintext highlighter-rouge">want</code> field of our struct?</p>

<p>This is where some Zig magic comes in: on obscure builtin function we can use inside of our <code class="language-plaintext highlighter-rouge">parse</code> method:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const self = @fieldParentPtr(Self, "parser", parser);
</code></pre></div></div>

<p>To understand this, first let’s get a look at what these parameters are referring to:</p>

<p><img src="https://user-images.githubusercontent.com/3173176/110593977-7b7f6e80-8139-11eb-8ecc-41dff5766ec2.png" alt="image" /></p>

<p>We can see from the Zig documentation that this function operates as follows:</p>

<blockquote>
  <p>Given a pointer to a field, returns the base pointer of a struct.</p>
</blockquote>

<p>So in our case:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Self</code> is the “parent struct” we’re trying to acquire a reference to (our type)</li>
  <li><code class="language-plaintext highlighter-rouge">"parser"</code> is the name of our struct’s field.</li>
  <li><code class="language-plaintext highlighter-rouge">parser</code> is the <em>pointer to our <code class="language-plaintext highlighter-rouge">parser</code> struct field</em>.</li>
</ul>

<p>Hopefully you can start to see the link here: <code class="language-plaintext highlighter-rouge">parser</code> is a pointer to <em>our struct field</em>, so Zig has a little helper <code class="language-plaintext highlighter-rouge">@fieldParentPtr</code> which can rely on that fact to give us <em>our struct</em> given a pointer to <em>our struct field</em>.</p>

<h3 id="implementing-the-rest-of-parse">Implementing the rest of <code class="language-plaintext highlighter-rouge">parse</code></h3>

<p>Our full <code class="language-plaintext highlighter-rouge">parse</code> method will look like this:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// If a value is returned, it is up to the caller to free it.</span>
<span class="k">fn</span> <span class="n">parse</span><span class="p">(</span><span class="n">parser</span><span class="p">:</span> <span class="o">*</span><span class="n">Parser</span><span class="p">([]</span><span class="kt">u8</span><span class="p">,</span> <span class="n">Reader</span><span class="p">),</span> <span class="n">allocator</span><span class="p">:</span> <span class="o">*</span><span class="n">Allocator</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="o">*</span><span class="n">Reader</span><span class="p">)</span> <span class="k">callconv</span><span class="p">(.</span><span class="py">Inline</span><span class="p">)</span> <span class="n">Error</span><span class="o">!?</span><span class="p">[]</span><span class="kt">u8</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">self</span> <span class="o">=</span> <span class="nb">@fieldParentPtr</span><span class="p">(</span><span class="n">Self</span><span class="p">,</span> <span class="s">"parser"</span><span class="p">,</span> <span class="n">parser</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">try</span> <span class="n">allocator</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="py">want</span><span class="p">.</span><span class="py">len</span><span class="p">);</span>
    <span class="k">errdefer</span> <span class="n">allocator</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">read</span> <span class="o">=</span> <span class="k">try</span> <span class="n">src</span><span class="p">.</span><span class="nf">reader</span><span class="p">().</span><span class="nf">readAll</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="py">want</span><span class="p">.</span><span class="py">len</span> <span class="k">or</span> <span class="o">!</span><span class="n">std</span><span class="p">.</span><span class="py">mem</span><span class="p">.</span><span class="nf">eql</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="py">want</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">try</span> <span class="n">src</span><span class="p">.</span><span class="nf">seekableStream</span><span class="p">().</span><span class="nf">seekBy</span><span class="p">(</span><span class="o">-</span><span class="nb">@intCast</span><span class="p">(</span><span class="kt">i64</span><span class="p">,</span> <span class="n">read</span><span class="p">));</span>
        <span class="n">allocator</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="c">// parsing failed</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There are a few notable things here:</p>

<ul>
  <li>We’re trying to return a string from our <code class="language-plaintext highlighter-rouge">parse</code> function, i.e. the value it emits is a string (instead of an AST node).</li>
  <li>The <code class="language-plaintext highlighter-rouge">want</code> string we <em>got</em> inside of our <code class="language-plaintext highlighter-rouge">init</code> method is agreed to only be valid while <code class="language-plaintext highlighter-rouge">parse</code> will still be called. We’ve decided to create a contract that all of our <code class="language-plaintext highlighter-rouge">Parser</code> implementations will either not hold onto memory given by others - or if they do, only do so until <code class="language-plaintext highlighter-rouge">parse</code> returns. Hence, we need to allocate a new string in our method.</li>
  <li>Normally we could rely solely on <code class="language-plaintext highlighter-rouge">defer</code> (“run at end of function”) or <code class="language-plaintext highlighter-rouge">errdefer</code> (“run if an error is returned”), but since we’ve chosen to reserve the <em>none optional</em> <code class="language-plaintext highlighter-rouge">null</code> as “we didn’t parse anything” we need to manually free if we <code class="language-plaintext highlighter-rouge">return null;</code>. A <code class="language-plaintext highlighter-rouge">nulldefer</code> and <code class="language-plaintext highlighter-rouge">somedefer</code> could be nice, maybe?</li>
</ul>

<p>Putting it all together, you’ll get something like this: <a href="https://gist.github.com/slimsag/8f098a13177b4bc008a7741505819f90">GitHub gist</a>.</p>

<h2 id="our-first-parser-combinator">Our first <em>parser combinator</em></h2>

<p>To demonstrate how a <em>parser combinator</em> would be implemented, we’ll try implementing the <code class="language-plaintext highlighter-rouge">OneOf</code> operator. It will take any number of <em>parsers</em> as input and run them consecutively until one succeeds or none do.</p>

<p>Let’s first start by writing out the basic structure of our function:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">OneOf</span><span class="p">(</span><span class="k">comptime</span> <span class="n">Value</span><span class="p">:</span> <span class="k">type</span><span class="p">,</span> <span class="k">comptime</span> <span class="n">Reader</span><span class="p">:</span> <span class="k">type</span><span class="p">)</span> <span class="k">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">(</span><span class="n">Value</span><span class="p">,</span> <span class="n">Reader</span><span class="p">)</span> <span class="o">=</span> <span class="o">.</span><span class="p">{</span>
            <span class="p">.</span><span class="py">_parse</span> <span class="o">=</span> <span class="n">parse</span><span class="p">,</span>
        <span class="p">},</span>

        <span class="o">...</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You’ll notice here that in contrast to our <code class="language-plaintext highlighter-rouge">Literal</code> <em>parser</em> function from earlier, this function takes a second <code class="language-plaintext highlighter-rouge">comptime Value: type</code> parameter. This is because we want it to work with any existing <code class="language-plaintext highlighter-rouge">Parser</code> implementation, regardless of what type of value it produces.</p>

<p>We can start to fill in the type by adding our <code class="language-plaintext highlighter-rouge">init</code> method:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">OneOf</span><span class="p">(</span><span class="k">comptime</span> <span class="n">Value</span><span class="p">:</span> <span class="k">type</span><span class="p">,</span> <span class="k">comptime</span> <span class="n">Reader</span><span class="p">:</span> <span class="k">type</span><span class="p">)</span> <span class="k">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">(</span><span class="n">Value</span><span class="p">,</span> <span class="n">Reader</span><span class="p">)</span> <span class="o">=</span> <span class="o">.</span><span class="p">{</span>
            <span class="p">.</span><span class="py">_parse</span> <span class="o">=</span> <span class="n">parse</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">parsers</span><span class="p">:</span> <span class="p">[]</span><span class="o">*</span><span class="n">Parser</span><span class="p">(</span><span class="n">Value</span><span class="p">,</span> <span class="n">Reader</span><span class="p">),</span>

        <span class="k">const</span> <span class="n">Self</span> <span class="o">=</span> <span class="nb">@This</span><span class="p">();</span>

        <span class="c">// `parsers` slice must stay alive for as long as the parser will be</span>
        <span class="c">// used.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="n">init</span><span class="p">(</span><span class="n">parsers</span><span class="p">:</span> <span class="p">[]</span><span class="o">*</span><span class="n">Parser</span><span class="p">(</span><span class="n">Value</span><span class="p">,</span> <span class="n">Reader</span><span class="p">))</span> <span class="n">Self</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">Self</span><span class="p">{</span>
                <span class="p">.</span><span class="py">parsers</span> <span class="o">=</span> <span class="n">parsers</span><span class="p">,</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see here, we’re going to simply take in a list of pointers to parsers. They’ll all need to have the same return <code class="language-plaintext highlighter-rouge">Value</code> as was specified in the call to <code class="language-plaintext highlighter-rouge">OneOf</code>.</p>

<p>One reason for this is that <a href="https://github.com/ziglang/zig/issues/447">Zig does not support <em>return type inference</em></a>. You can have a function which takes <code class="language-plaintext highlighter-rouge">anytype</code> as a parameter, but it cannot return an <code class="language-plaintext highlighter-rouge">anytype</code>. This just means we need to have a generic function (in this case, <code class="language-plaintext highlighter-rouge">OneOf</code>) which accepts a type parameter and then use that <code class="language-plaintext highlighter-rouge">Value</code> type later. In a language like Haskell or OCaml, this would not be true.</p>

<p>Finally, we can implement our <code class="language-plaintext highlighter-rouge">parse</code> method:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">OneOf</span><span class="p">(</span><span class="k">comptime</span> <span class="n">Value</span><span class="p">:</span> <span class="k">type</span><span class="p">,</span> <span class="k">comptime</span> <span class="n">Reader</span><span class="p">:</span> <span class="k">type</span><span class="p">)</span> <span class="k">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="o">...</span>

        <span class="c">// Caller is responsible for freeing the value, if any.</span>
        <span class="k">fn</span> <span class="n">parse</span><span class="p">(</span><span class="n">parser</span><span class="p">:</span> <span class="o">*</span><span class="n">Parser</span><span class="p">(</span><span class="n">Value</span><span class="p">,</span> <span class="n">Reader</span><span class="p">),</span> <span class="n">allocator</span><span class="p">:</span> <span class="o">*</span><span class="n">Allocator</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="o">*</span><span class="n">Reader</span><span class="p">)</span> <span class="k">callconv</span><span class="p">(.</span><span class="py">Inline</span><span class="p">)</span> <span class="n">Error</span><span class="o">!?</span><span class="n">Value</span> <span class="p">{</span>
            <span class="k">const</span> <span class="n">self</span> <span class="o">=</span> <span class="nb">@fieldParentPtr</span><span class="p">(</span><span class="n">Self</span><span class="p">,</span> <span class="s">"parser"</span><span class="p">,</span> <span class="n">parser</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="py">parsers</span><span class="p">)</span> <span class="p">|</span> <span class="n">one_of_parser</span> <span class="p">|</span> <span class="p">{</span>
                <span class="k">const</span> <span class="n">result</span> <span class="o">=</span> <span class="k">try</span> <span class="n">one_of_parser</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">allocator</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There are a few things to unpack here:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">try one_of_parser.parse(allocator, src);</code> indicates that if parsing using <code class="language-plaintext highlighter-rouge">one_of_parser</code> returns an <em>error</em> that our function should return immediately and not continue attempting to parse with other parsers.</li>
  <li><code class="language-plaintext highlighter-rouge">if (result != null) {</code> is how you check if an Optional type in Zig is “None”. I find this pretty interesting: it’s not <code class="language-plaintext highlighter-rouge">null</code>, it’s actually an optional “none” type - but it is called <code class="language-plaintext highlighter-rouge">null</code>. I’m not sure why, but can imagine this making the language friendlier to people unfamiliar with optional types.</li>
</ul>

<h2 id="using-our-oneof-parser-combinator">Using our OneOf parser combinator</h2>

<p>Now for the cool part: we get to put both our <code class="language-plaintext highlighter-rouge">Literal</code> parser and <code class="language-plaintext highlighter-rouge">OneOf</code> parser combinator to <em>build a new parser</em>!</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Define our parser.</span>
<span class="k">var</span> <span class="n">one_of</span> <span class="o">=</span> <span class="n">OneOf</span><span class="p">([]</span><span class="kt">u8</span><span class="p">,</span> <span class="nb">@TypeOf</span><span class="p">(</span><span class="n">reader</span><span class="p">)).</span><span class="nf">init</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
    <span class="o">&amp;</span><span class="n">Literal</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">reader</span><span class="p">)).</span><span class="nf">init</span><span class="p">(</span><span class="s">"dog"</span><span class="p">).</span><span class="py">parser</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">Literal</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">reader</span><span class="p">)).</span><span class="nf">init</span><span class="p">(</span><span class="s">"sheep"</span><span class="p">).</span><span class="py">parser</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">Literal</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">reader</span><span class="p">)).</span><span class="nf">init</span><span class="p">(</span><span class="s">"cat"</span><span class="p">).</span><span class="py">parser</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div>

<p>The above will parse one of <code class="language-plaintext highlighter-rouge">"dog"</code>, <code class="language-plaintext highlighter-rouge">"sheep"</code>, or <code class="language-plaintext highlighter-rouge">"cat"</code> from the input reader.</p>

<p>We’re passing <code class="language-plaintext highlighter-rouge">@TypeOf(reader)</code> frequently above which makes the code a bit more cryptic than needed, and it would be possible to introduce a <code class="language-plaintext highlighter-rouge">OneOfLiteral</code> helper which makes the above instead read:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Define our parser.</span>
<span class="k">var</span> <span class="n">one_of</span> <span class="o">=</span> <span class="n">OneOfLiteral</span><span class="p">([]</span><span class="kt">u8</span><span class="p">,</span> <span class="nb">@TypeOf</span><span class="p">(</span><span class="n">reader</span><span class="p">)).</span><span class="nf">init</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
    <span class="s">"dog"</span><span class="p">,</span>
    <span class="s">"cat"</span><span class="p">,</span>
    <span class="s">"sheep"</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div>

<p>One thing to unpack here is this syntax for passing an array to <code class="language-plaintext highlighter-rouge">init</code>: <code class="language-plaintext highlighter-rouge">&amp;.{...}</code>:</p>

<ul>
  <li>The function takes a parameter <code class="language-plaintext highlighter-rouge">parsers: []*Parser(Value, Reader)</code></li>
  <li><code class="language-plaintext highlighter-rouge">.{...}</code> would give us <em>a fixed size array</em> <code class="language-plaintext highlighter-rouge">[3]*Parser(Value, Reader)</code></li>
  <li><code class="language-plaintext highlighter-rouge">&amp;.{}</code> gives us a pointer to an array, i.e. <em>a slice</em> <code class="language-plaintext highlighter-rouge">[]*Parser(Value, Reader)</code>.</li>
</ul>

<p>Since our list is known at compile time, we don’t have to allocate or free memory for the slice. If our list was dynamic, we would need to do so.</p>

<p>Finally, we can actually use our parser above:</p>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">one_of</span><span class="p">.</span><span class="py">parser</span><span class="p">;</span>
<span class="k">var</span> <span class="n">result</span> <span class="o">=</span> <span class="k">try</span> <span class="n">p</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reader</span><span class="p">);</span>
<span class="n">std</span><span class="p">.</span><span class="py">testing</span><span class="p">.</span><span class="nf">expectEqualStrings</span><span class="p">(</span><span class="s">"cat"</span><span class="p">,</span> <span class="n">result</span><span class="o">.?</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">|</span><span class="n">r</span><span class="p">|</span> <span class="p">{</span>
    <span class="n">allocator</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="runtime-parser-generation">Runtime parser generation</h2>

<p>You might be wondering how we would go from the <code class="language-plaintext highlighter-rouge">Literal</code> <em>parser</em> and <code class="language-plaintext highlighter-rouge">OneOf</code> <em>parser combinator</em> to actually <em>generating a parser at runtime that can parse the semantics defined in a regexp string</em>.</p>

<p>Since our <code class="language-plaintext highlighter-rouge">Parser</code> interface is a runtime interface (you can swap out the implementation at runtime) and since our parser combinator <code class="language-plaintext highlighter-rouge">OneOf</code> operates using that interface (only the return value must be known at compile time, it could be a generic AST node) it means that we can easily dynamically create slices of <code class="language-plaintext highlighter-rouge">[]*Parser(...)</code> at runtime based on the result of a parser combinator we have built - like our “dog, cat, sheep” parser from earlier.</p>

<p>The challenge left for you as a reader is to:</p>

<ul>
  <li>Write <em>parsers</em> like our <code class="language-plaintext highlighter-rouge">Literal</code> parser that can parse the components of our regexp <code class="language-plaintext highlighter-rouge">a[bc].*abc</code>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">RegexLiteralParser</code> can parse <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code>, but not <code class="language-plaintext highlighter-rouge">abc</code> (the string.)</li>
      <li><code class="language-plaintext highlighter-rouge">RegexRangeOpenParser</code> can parse <code class="language-plaintext highlighter-rouge">[</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">RegexRangeCloseParser</code> can parse <code class="language-plaintext highlighter-rouge">]</code></li>
      <li><code class="language-plaintext highlighter-rouge">RegexAnyParser</code> can parse the <code class="language-plaintext highlighter-rouge">.</code> “any character” syntax.</li>
      <li><code class="language-plaintext highlighter-rouge">RegexRepetitionParser</code> can parse the <code class="language-plaintext highlighter-rouge">*</code> repetition operator.</li>
    </ul>
  </li>
  <li>Write a <em>parser combinators</em> like our <code class="language-plaintext highlighter-rouge">OneOf</code> parser, except have it parse a <code class="language-plaintext highlighter-rouge">Sequence</code> of parsers.</li>
  <li>Use our <code class="language-plaintext highlighter-rouge">Sequence</code> parser combinator and <code class="language-plaintext highlighter-rouge">RegexLiteralParser</code> to build a <code class="language-plaintext highlighter-rouge">RegexStringLiteralParser</code> - similar to how we built out “dog, cat, sheep” parser.</li>
  <li>Write a <em>new kind of function</em> called a <em>runtime parser generator</em> named <code class="language-plaintext highlighter-rouge">RegexParser</code> which will be super familiar:
    <ul>
      <li>Take in a <em>parser combinator</em> called <code class="language-plaintext highlighter-rouge">RegexSyntaxParser</code> which can turn your regexp syntax into some intermediary like an AST.</li>
      <li>Have your function <em>use parser combinators like OneOf, Sequence, etc.</em> to build a brand new parser at runtime based on that intermediary AST.</li>
      <li>Return that new parser which parses the actual semantics described by the input regexp!</li>
    </ul>
  </li>
</ul>

<h2 id="closing-thoughts">Closing thoughts</h2>

<p>I am sorry for not giving you a full (or even partial) regex engine :) I am still exploring this and it is a large undertaking, this blog post would be far too long if it was included.</p>

<p>You can find a copy of the final code with <em>parsers</em> and <em>parser combinators</em> <a href="https://gist.github.com/slimsag/db2dd2c49aa038e23b654120e70c9b00">here</a>. Just <code class="language-plaintext highlighter-rouge">zig init-exe</code> and plop them into your <code class="language-plaintext highlighter-rouge">src/</code> directory.</p>

<p>You may also want to check out <a href="https://github.com/Hejsil/mecha">Mecha</a>, a parser combinator library for Zig.</p>

<p>If anything was unclear or confusing, I’m happy to help: shoot me an email stephen@hexops.com or leave a comment on Hacker News / Reddit and I’ll follow up.</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      <a alt="Twitter" href="https://twitter.com/slimsag""><img src="https://shields.io/badge/Twitter-follow-blue?logo=Twitter" class="color"></a>
&nbsp;
<a alt="RSS Follow" href="/feed.xml""><img src="https://shields.io/badge/RSS-follow-green?logo=RSS" class="color"></a>
&nbsp;
<a alt="License: CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0"><img src="https://img.shields.io/badge/License-CC%20BY%204.0-lightgrey.svg" class="color"></a>
&nbsp;
<a alt="Hexops on GitHub" href="https://github.com/hexops" class="github color" style="background-image: url(https://raw.githubusercontent.com/simple-icons/simple-icons/develop/icons/github.svg);line-height: 1;padding-left: 1.5rem;background-repeat: no-repeat;padding-top: .25rem;"> GitHub</a>
<br>
<br>
<a href="https://hexops.com"><img class="logo color" height="50px" alt="Hexops logo" src="https://raw.githubusercontent.com/hexops/media/main/logo.svg"></a>
<br>


&copy;  2021 Hexops
<link rel="me" href="mailto:support@hexops.com">
    </p>

  </div>

</footer>


  </body>

</html>
